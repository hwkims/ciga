<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸš¬ ìŠ¤ë§ˆíŠ¸ ê¸ˆì—° ë„ìš°ë¯¸ ğŸš­</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #e0f7fa; /* Light Teal Background */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align items to the top */
            min-height: 100vh; /* Ensure full viewport height */
        }

        h1 {
            text-align: center;
            color: #263238; /* Dark Blue Gray */
            margin-top: 20px;
            margin-bottom: 20px;
        }

        #container {
            position: relative;
            width: 640px;
            height: 480px;
            border: 2px solid #b2ebf2; /* Light Teal Border */
            background-color: #fff;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* Subtle shadow */
            border-radius: 8px;
            overflow: hidden; /* Clip canvas overflow */
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            pointer-events: none;
        }

        #log-container { /* Container for log and sound control */
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* Align items to the top within the container */
            width: 640px;
            margin-top: 20px;
            margin-bottom: 20px;
        }

        #log {
            padding: 15px;
            width: 480px; /* Adjusted width for log */
            max-height: 200px;
            overflow-y: auto;
            background-color: #37474f; /* Dark Gray for Log */
            color: #eceff1; /* Light Gray for Log Text */
            font-family: monospace;
            border-radius: 8px;
            border: 1px solid #546e7a; /* Medium Gray Border */
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
            font-size: 14px;
            line-height: 1.4;
        }

        #sound-control { /* Sound control area */
            width: 140px; /* Adjusted width for sound control */
            padding: 15px;
            background-color: #fff;
            border: 1px solid #b2ebf2;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            text-align: center;
        }

        #sound-control button {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            background-color: #00bcd4; /* Teal Button */
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s ease;
        }

        #sound-control button:hover {
            background-color: #00acc1; /* Darker Teal on Hover */
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            body {
                padding: 20px;
            }
            #container, #log-container, #log {
                width: 95%; /* Make container and log responsive */
                max-width: 640px; /* Limit max width */
            }
            #log-container {
                flex-direction: column; /* Stack log and sound control on smaller screens */
                align-items: stretch; /* Stretch items to full width */
            }
            #log, #sound-control {
                width: 100%; /* Full width for log and sound control */
                margin-bottom: 10px; /* Add spacing between stacked items */
            }
        }
    </style>
</head>
<body>
    <h1>ğŸš¬ ìŠ¤ë§ˆíŠ¸ ê¸ˆì—° ë„ìš°ë¯¸ ğŸš­</h1>
    <div id="container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="canvas" width="640" height="480"></canvas>
    </div>
    <div id="log-container">
        <div id="log"></div>
        <div id="sound-control">
            <button id="toggleSound">ì†Œë¦¬ ì•Œë¦¼ ì¼œê¸°/ë„ê¸°</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.20.1/dist/ort.min.js"></script>
    <script>
        // --- ì „ì—­ ë³€ìˆ˜ ---
        let alertSound = new Audio('alert_sound.mp3'); // ì•Œë¦¼ ì†Œë¦¬ íŒŒì¼ ê²½ë¡œ
        let isPlaying = false;
        let soundEnabled = true; // ì†Œë¦¬ ì•Œë¦¼ í™œì„±í™” ìƒíƒœ

        // --- HTML ìš”ì†Œ ---
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const logElement = document.getElementById('log');
        const toggleSoundButton = document.getElementById('toggleSound');

        // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---
        toggleSoundButton.addEventListener('click', toggleSoundAlert);

        // --- í•¨ìˆ˜ ---

        // ì†Œë¦¬ ì•Œë¦¼ í† ê¸€ í•¨ìˆ˜
        function toggleSoundAlert() {
            soundEnabled = !soundEnabled;
            toggleSoundButton.textContent = soundEnabled ? 'ì†Œë¦¬ ì•Œë¦¼ ë„ê¸°' : 'ì†Œë¦¬ ì•Œë¦¼ ì¼œê¸°';
            if (!soundEnabled && isPlaying) {
                stopSound(); // ì†Œë¦¬ ë„ê¸°
            }
            logMessage(soundEnabled ? "ì†Œë¦¬ ì•Œë¦¼ ì¼œì§" : "ì†Œë¦¬ ì•Œë¦¼ êº¼ì§");
        }

        // ì›¹ìº  ì´ˆê¸°í™”
        function initWebcam() {
            navigator.mediaDevices.getUserMedia({ video: true })
                .then((stream) => {
                    video.srcObject = stream;
                    video.play();
                })
                .catch((error) => {
                    console.error('ì›¹ìº  ì ‘ê·¼ ì˜¤ë¥˜:', error);
                    logMessage('ì›¹ìº  ì ‘ê·¼ ì˜¤ë¥˜: ' + error);
                });
        }

        // ëª¨ë¸ ë¡œë“œ
        let session;
        async function loadModel() {
            try {
                session = await ort.InferenceSession.create('yolov8_model.onnx');
                console.log("ëª¨ë¸ ë¡œë“œ ì™„ë£Œ");
                logMessage("ëª¨ë¸ ë¡œë“œ ì™„ë£Œ");
                startDetection();
            } catch (err) {
                console.error("ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨:", err);
                logMessage("ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨: " + err);
            }
        }

        // ê°ì²´ íƒì§€ ì‹œì‘
        async function startDetection() {
            async function detectObjects() {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                let frame = canvas;

                // ì´ë¯¸ì§€ ì „ì²˜ë¦¬ ë° í…ì„œ ë³€í™˜
                let tensor = preprocessImage(frame);

                // ì¶”ë¡  ì‹¤í–‰
                try {
                    const feeds = {'images': tensor}; // Yolov8 ëª¨ë¸ ì…ë ¥ ì´ë¦„ 'images' ë¡œ ê°€ì • (ì¼ë°˜ì ì¸ ì´ë¦„)
                    const outputData = await session.run(feeds);

                    // --- ì¶œë ¥ ì²˜ë¦¬ ---
                    const output = outputData['output0']; // Yolov8 ëª¨ë¸ ì¶œë ¥ ì´ë¦„ 'output0' ë¡œ ê°€ì • (ì¼ë°˜ì ì¸ ì´ë¦„)
                    if (!output || !output.data) {
                        console.warn("ëª¨ë¸ ì¶œë ¥ì´ ì—†ìŠµë‹ˆë‹¤.");
                        requestAnimationFrame(detectObjects);
                        return;
                    }

                    const detections = output.data; // outputs are flattened arrays
                    const numDetections = output.dims[1]; // Number of detections
                    const boxes = [];
                    const scores = [];
                    const classIds = [];

                    // YOLOv8 ì¶œë ¥ íŒŒì‹± (ì¼ë°˜ì ì¸ ì¶œë ¥ í˜•íƒœ ê°€ì •)
                    for (let i = 0; i < numDetections; ++i) {
                        const offset = i * 84; // Assuming 84 elements per detection (xywh, confidence, 80 classes)
                        const confidence = detections[4 + offset]; // 5th element is confidence

                        if (confidence > 0.5) { // ì‹ ë¢°ë„ 50% ì´ìƒ í•„í„°ë§
                            const classScores = detections.slice(5 + offset, 85 + offset); // Class probabilities
                            const classId = classScores.indexOf(Math.max(...classScores)); // Get class with highest probability

                            if (classId === 1) { // í´ë˜ìŠ¤ IDê°€ 1ì´ë©´ 'cigarette' (í´ë˜ìŠ¤ ID í™•ì¸ í•„ìš”!)
                                const xCenter = detections[offset];
                                const yCenter = detections[1 + offset];
                                const width = detections[2 + offset];
                                const height = detections[3 + offset];
                                const x = (xCenter - width / 2) * canvas.width;   // Scale box to canvas size
                                const y = (yCenter - height / 2) * canvas.height;
                                const boxWidth = width * canvas.width;
                                const boxHeight = height * canvas.height;

                                boxes.push([x, y, boxWidth, boxHeight]);
                                scores.push(confidence);
                                classIds.push(classId);
                            }
                        }
                    }

                    // --- 'cigarette' íƒì§€ ì—¬ë¶€ ë° ì•Œë¦¼ ì²˜ë¦¬ ---
                    let cigaretteDetected = classIds.includes(1); // í´ë˜ìŠ¤ ID 1 ì´ 'cigarette' ì´ë¼ê³  ê°€ì •

                    if (cigaretteDetected) {
                        drawBoundingBoxes(boxes, scores, classIds); // ë°•ìŠ¤ ê·¸ë¦¬ê¸°
                        if (soundEnabled && !isPlaying) {
                            playSound(); // ì†Œë¦¬ ì¬ìƒ
                            logMessage("ğŸš¬ ë‹´ë°°ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸš­");
                        }
                    } else {
                        clearCanvas(); // ìº”ë²„ìŠ¤ ì§€ìš°ê¸° (íƒì§€ ì•ˆë˜ë©´ ë°•ìŠ¤ ì œê±°)
                        if (isPlaying) {
                            stopSound(); // ì†Œë¦¬ ì •ì§€
                            logMessage("íƒì§€ ëŒ€ê¸° ì¤‘...");
                        }
                    }

                } catch (error) {
                    console.error("ì¶”ë¡  ì˜¤ë¥˜:", error);
                    logMessage("ì¶”ë¡  ì˜¤ë¥˜: " + error);
                } finally {
                    requestAnimationFrame(detectObjects); // ë‹¤ìŒ í”„ë ˆì„ì—ì„œ ë‹¤ì‹œ íƒì§€
                }
            }

            detectObjects();
        }

        // ì›¹ìº  ì´ë¯¸ì§€ ì „ì²˜ë¦¬ ë° í…ì„œ ë³€í™˜
        function preprocessImage(frame) {
            // ëª¨ë¸ ì…ë ¥ ì‚¬ì´ì¦ˆì— ë§ì¶° ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì • (YOLOv8 ì¼ë°˜ì ì¸ ì…ë ¥ ì‚¬ì´ì¦ˆ 640x640)
            canvas.width = 640;
            canvas.height = 640;
            ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = new Float32Array(3 * canvas.width * canvas.height);
            let index = 0;

            // RGBA -> RGB ë³€í™˜ ë° ì •ê·œí™” (0~1)
            for (let i = 0; i < imageData.data.length; i += 4) {
                data[index++] = imageData.data[i] / 255.0;     // Red
                data[index++] = imageData.data[i + 1] / 255.0; // Green
                data[index++] = imageData.data[i + 2] / 255.0; // Blue
            }

            // ëª¨ë¸ ì…ë ¥ í˜•íƒœì— ë§ê²Œ í…ì„œ ìƒì„± (NCHW, Float32)
            const tensor = new ort.Tensor('float32', data, [1, 3, canvas.width, canvas.height]);
            return tensor;
        }


        // ë°•ìŠ¤ ê·¸ë¦¬ê¸° (ë‹¤ìˆ˜ì˜ ë°•ìŠ¤ ì²˜ë¦¬)
        function drawBoundingBoxes(boxes, scores, classIds) {
            clearCanvas(); // ê¸°ì¡´ ë°•ìŠ¤ ì§€ìš°ê¸°
            boxes.forEach((box, index) => {
                const x = box[0];
                const y = box[1];
                const width = box[2];
                const height = box[3];
                const score = scores[index];
                const classId = classIds[index];

                ctx.beginPath();
                ctx.rect(x, y, width, height);
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'red';
                ctx.fillStyle = 'red';
                ctx.stroke();

                // ë¼ë²¨ í…ìŠ¤íŠ¸ (í´ë˜ìŠ¤ ì´ë¦„ ë° ì‹ ë¢°ë„)
                const className = getClassLabel(classId); // í´ë˜ìŠ¤ IDë¡œë¶€í„° ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
                const labelText = `${className} ${(score * 100).toFixed(0)}%`;
                ctx.font = "14px Arial";
                ctx.fillStyle = "red";
                ctx.fillText(labelText, x, y - 5); // ë°•ìŠ¤ ìœ„ì— í…ìŠ¤íŠ¸ í‘œì‹œ
            });
        }

        // ìº”ë²„ìŠ¤ ë‚´ìš© ì§€ìš°ê¸°
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // í´ë˜ìŠ¤ IDë¡œë¶€í„° í´ë˜ìŠ¤ ì´ë¦„ ê°€ì ¸ì˜¤ê¸° (í•„ìš”ì— ë”°ë¼ ìˆ˜ì •)
        function getClassLabel(classId) {
            // YOLOv8 COCO classes index 1 is 'person'.  If your model trained differently, adjust this.
            // This is just example, please adjust this based on your trained model's class index.
            if (classId === 1) {
                return 'Cigarette'; // í´ë˜ìŠ¤ ID 1ì„ 'Cigarette'ìœ¼ë¡œ ê°€ì •
            } else {
                return 'Unknown';
            }
        }


        // ì†Œë¦¬ ì¬ìƒ
        function playSound() {
            alertSound.loop = true; // ë°˜ë³µ ì¬ìƒ ì„¤ì •
            alertSound.play().then(() => {
                isPlaying = true;
            }).catch(error => {
                console.error("ì†Œë¦¬ ì¬ìƒ ì˜¤ë¥˜:", error);
                logMessage("ì†Œë¦¬ ì¬ìƒ ì˜¤ë¥˜: " + error);
            });
        }

        // ì†Œë¦¬ ì •ì§€
        function stopSound() {
            alertSound.pause();
            alertSound.currentTime = 0; // ì¬ìƒ ìœ„ì¹˜ ì²˜ìŒìœ¼ë¡œ
            isPlaying = false;
        }


        // ë¡œê·¸ ë©”ì‹œì§€ ì¶”ê°€
        function logMessage(message) {
            const newLog = document.createElement('div');
            newLog.textContent = message;
            logElement.appendChild(newLog);
            logElement.scrollTop = logElement.scrollHeight; // ìë™ ìŠ¤í¬ë¡¤
        }

        // --- ì´ˆê¸°í™” ---
        window.onload = function () {
            logMessage("í˜ì´ì§€ ë¡œë“œ ì™„ë£Œ. ëª¨ë¸ ë¡œë”© ì‹œì‘...");
            initWebcam(); // ì›¹ìº  ì´ˆê¸°í™”
            if (typeof ort !== 'undefined') {
                loadModel(); // ONNX Runtime ë¡œë“œ í›„ ëª¨ë¸ ë¡œë“œ
            } else {
                console.error("onnxruntime-web ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ ì‹¤íŒ¨");
                logMessage("onnxruntime-web ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ ì‹¤íŒ¨");
            }
        };
    </script>
</body>
</html>
