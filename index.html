<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLOv8 Cigarette Detection</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }
        #container {
            position: relative;
            width: 640px;
            height: 480px;
            border: 2px solid #ccc;
            background-color: #fff;
            margin-bottom: 10px;
        }
        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            pointer-events: none;
        }
        #log {
            padding: 10px;
            width: 640px;
            max-height: 200px;
            overflow-y: auto;
            background-color: #222;
            color: #fff;
            font-family: monospace;
            border-radius: 5px;
            border: 2px solid #333;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <h1>YOLOv8 Cigarette Detection</h1>
    <div id="container">
        <video id="webcam" autoplay muted playsinline></video>
        <canvas id="canvas" width="640" height="480"></canvas>
    </div>
    <div id="log"></div>

    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/ort.min.js"></script>
    <script>
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const logElement = document.getElementById('log');
        
        // GitHub Pages에서 제공되는 소리 파일 경로
        const alertSound = new Audio('https://hwkims.github.io/ciga/alert_sound.mp3');
        let isPlaying = false;
        let session;
        const cigaretteClassId = 0; // 모델에 따라 확인 필요

        function logMessage(message) {
            const newLog = document.createElement('div');
            newLog.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logElement.appendChild(newLog);
            logElement.scrollTop = logElement.scrollHeight;
        }

        async function initWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480 } 
                });
                video.srcObject = stream;
                await video.play();
                logMessage("Webcam initialized successfully");
            } catch (error) {
                logMessage(`Webcam error: ${error.message}`);
                throw error;
            }
        }

        async function loadModel() {
            try {
                session = await ort.InferenceSession.create(
                    'https://hwkims.github.io/ciga/yolov8_model.onnx',
                    { executionProviders: ['webgl'] }
                );
                logMessage("Model loaded successfully");
                return true;
            } catch (error) {
                logMessage(`Model loading error: ${error.message}`);
                throw error;
            }
        }

        function preprocessImage(img) {
            const canvas = document.createElement('canvas');
            canvas.width = 640;
            canvas.height = 640;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, 640, 640);
            const imageData = ctx.getImageData(0, 0, 640, 640);
            const data = imageData.data;

            const inputData = new Float32Array(3 * 640 * 640);
            for (let i = 0; i < data.length; i += 4) {
                const idx = i / 4;
                inputData[idx] = data[i] / 255.0;           // R
                inputData[640 * 640 + idx] = data[i + 1] / 255.0; // G
                inputData[2 * 640 * 640 + idx] = data[i + 2] / 255.0; // B
            }
            return new ort.Tensor('float32', inputData, [1, 3, 640, 640]);
        }

        function xywh2xyxy(x, y, w, h) {
            return [
                x - w / 2,
                y - h / 2,
                x + w / 2,
                y + h / 2
            ];
        }

        function nonMaxSuppression(boxes, scores, iouThreshold) {
            const indices = Array.from({length: scores.length}, (_, i) => i);
            indices.sort((a, b) => scores[b] - scores[a]);
            
            const keep = [];
            while (indices.length > 0) {
                const current = indices.shift();
                keep.push(current);
                
                for (let i = indices.length - 1; i >= 0; i--) {
                    const iou = calculateIoU(boxes[current], boxes[indices[i]]);
                    if (iou > iouThreshold) {
                        indices.splice(i, 1);
                    }
                }
            }
            
            return keep.map(i => ({
                box: boxes[i],
                score: scores[i]
            }));
        }

        function calculateIoU(box1, box2) {
            const [x1, y1, x2, y2] = box1;
            const [x1b, y1b, x2b, y2b] = box2;
            const xi1 = Math.max(x1, x1b);
            const yi1 = Math.max(y1, y1b);
            const xi2 = Math.min(x2, x2b);
            const yi2 = Math.min(y2, y2b);
            const interArea = Math.max(0, xi2 - xi1) * Math.max(0, yi2 - yi1);
            const box1Area = (x2 - x1) * (y2 - y1);
            const box2Area = (x2b - x1b) * (y2b - y1b);
            return interArea / (box1Area + box2Area - interArea);
        }

        function processOutput(output) {
            const data = output[Object.keys(output)[0]].data;
            const [_, numDetections, numElements] = output[Object.keys(output)[0]].dims;

            const boxes = [];
            const scores = [];

            for (let i = 0; i < numDetections; i++) {
                const offset = i * numElements;
                const confidence = data[offset + 4];
                const classId = data[offset + 5]; // 클래스 ID 위치 확인 필요
                
                if (confidence > 0.5 && classId === cigaretteClassId) {
                    const x = data[offset];
                    const y = data[offset + 1];
                    const w = data[offset + 2];
                    const h = data[offset + 3];
                    
                    boxes.push(xywh2xyxy(x, y, w, h));
                    scores.push(confidence);
                }
            }

            return nonMaxSuppression(boxes, scores, 0.45);
        }

        function drawBoundingBox(x1, y1, x2, y2, score) {
            const width = x2 - x1;
            const height = y2 - y1;
            
            ctx.beginPath();
            ctx.rect(x1, y1, width, height);
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'red';
            ctx.stroke();
            
            ctx.font = '16px Arial';
            ctx.fillStyle = 'red';
            ctx.fillText(`Cigarette ${score.toFixed(2)}`, x1, y1 > 10 ? y1 - 5 : y1 + 15);
        }

        async function detectFrame() {
            if (!session) return;

            try {
                const tensor = preprocessImage(video);
                const feeds = { [session.inputNames[0]]: tensor };
                const results = await session.run(feeds);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const detections = processOutput(results);
                
                let cigaretteDetected = false;
                detections.forEach(({ box, score }) => {
                    const [x1, y1, x2, y2] = box.map(coord => coord * 640);
                    drawBoundingBox(x1, y1, x2, y2, score);
                    cigaretteDetected = true;
                });

                if (cigaretteDetected && !isPlaying) {
                    alertSound.play().catch(e => logMessage(`Audio error: ${e.message}`));
                    isPlaying = true;
                    logMessage("Cigarette detected! Playing alert");
                } else if (!cigaretteDetected && isPlaying) {
                    alertSound.pause();
                    alertSound.currentTime = 0;
                    isPlaying = false;
                    logMessage("No cigarette detected. Alert stopped");
                }
            } catch (error) {
                logMessage(`Detection error: ${error.message}`);
            }

            requestAnimationFrame(detectFrame);
        }

        async function init() {
            try {
                await initWebcam();
                await loadModel();
                detectFrame();
            } catch (error) {
                logMessage(`Initialization failed: ${error.message}`);
            }
        }

        window.onload = init;
    </script>
</body>
</html>
